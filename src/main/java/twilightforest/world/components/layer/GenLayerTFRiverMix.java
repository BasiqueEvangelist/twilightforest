package twilightforest.world.components.layer;

import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import net.minecraft.core.Holder;
import net.minecraft.resources.ResourceKey;
import net.minecraft.world.level.biome.Biome;
import twilightforest.init.TFBiomes;
import twilightforest.init.custom.BiomeLayerStack;
import twilightforest.init.custom.BiomeLayerTypes;
import twilightforest.world.components.layer.vanillalegacy.Area;
import twilightforest.world.components.layer.vanillalegacy.BiomeLayerFactory;
import twilightforest.world.components.layer.vanillalegacy.BiomeLayerType;
import twilightforest.world.components.layer.vanillalegacy.area.LazyArea;
import twilightforest.world.components.layer.vanillalegacy.context.Context;
import twilightforest.world.components.layer.vanillalegacy.context.LazyAreaContext;
import twilightforest.world.components.layer.vanillalegacy.traits.AreaTransformer2;
import twilightforest.world.components.layer.vanillalegacy.traits.DimensionOffset0Transformer;

import java.util.function.LongFunction;

public enum GenLayerTFRiverMix implements AreaTransformer2, DimensionOffset0Transformer {

	INSTANCE;

//	private GenLayer biomeLayer;
//	private GenLayer riverLayer;

//	public GenLayerTFRiverMix(long seed, GenLayer biomeLayer, GenLayer riverLayer) {
//		super(seed);
//		this.biomeLayer = biomeLayer;
//		this.riverLayer = riverLayer;
//	}

	/**
	 * Returns a list of integer values generated by this layer. These may be
	 * interpreted as temperatures, rainfall amounts, or biomeList[] indices
	 * based on the particular GenLayer subclass.
	 */
//	@Override
//	public int[] getInts(int x, int z, int width, int depth) {
//
//		int[] biomeInputs = this.biomeLayer.getInts(x, z, width, depth);
//		int[] riverInputs = this.riverLayer.getInts(x, z, width, depth);
//		int[] outputs = IntCache.getIntCache(width * depth);
//
//		int stream = Biome.getIdForBiome(TFBiomes.stream);
//
//		for (int i = 0; i < width * depth; ++i) {
//			if (riverInputs[i] == stream) {
//				outputs[i] = riverInputs[i] & 255;
//			} else {
//				outputs[i] = biomeInputs[i];
//			}
//		}
//
//		return outputs;
//	}


	@Override
	public ResourceKey<Biome> applyPixel(Context iNoiseRandom, Area area1, Area area2, int x, int z) {
		ResourceKey<Biome> biomeInputs = area1.getBiome(this.getParentX(x), this.getParentY(z));
		ResourceKey<Biome> riverInputs = area2.getBiome(this.getParentX(x), this.getParentY(z));

		ResourceKey<Biome> stream = TFBiomes.STREAM;

		if (riverInputs == stream) {
			return riverInputs;
		} else {
			return biomeInputs;
		}
	}

	public record Factory(long salt, Holder<BiomeLayerFactory> parentBiomes, Holder<BiomeLayerFactory> parentRiver) implements BiomeLayerFactory {
		public static final Codec<Factory> CODEC = RecordCodecBuilder.create(inst -> inst.group(
				Codec.LONG.fieldOf("salt").forGetter(Factory::salt),
				BiomeLayerStack.HOLDER_CODEC.fieldOf("parent_biomes").forGetter(Factory::parentBiomes),
				BiomeLayerStack.HOLDER_CODEC.fieldOf("parent_river").forGetter(Factory::parentRiver)
		).apply(inst, Factory::new));

		// TODO The naming for this makes awful sense, rename to being a biome-first filter (Stream) otherwise delegate to parent_biomes. Also parameterize
		@Override
		public LazyArea build(LongFunction<LazyAreaContext> contextFactory) {
			return INSTANCE.run(contextFactory.apply(this.salt), this.parentBiomes.get().build(contextFactory), this.parentRiver.get().build(contextFactory));
		}

		@Override
		public BiomeLayerType getType() {
			return BiomeLayerTypes.RIVER_MIX.get();
		}
	}
}
